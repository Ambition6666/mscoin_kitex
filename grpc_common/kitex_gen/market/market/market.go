// Code generated by Kitex v0.10.3. DO NOT EDIT.

package market

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "google.golang.org/protobuf/proto"
	market "grpc_common/kitex_gen/market"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"FindSymbolThumb": kitex.NewMethodInfo(
		findSymbolThumbHandler,
		newFindSymbolThumbArgs,
		newFindSymbolThumbResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindSymbolThumbTrend": kitex.NewMethodInfo(
		findSymbolThumbTrendHandler,
		newFindSymbolThumbTrendArgs,
		newFindSymbolThumbTrendResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindSymbolInfo": kitex.NewMethodInfo(
		findSymbolInfoHandler,
		newFindSymbolInfoArgs,
		newFindSymbolInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindCoinInfo": kitex.NewMethodInfo(
		findCoinInfoHandler,
		newFindCoinInfoArgs,
		newFindCoinInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"HistoryKline": kitex.NewMethodInfo(
		historyKlineHandler,
		newHistoryKlineArgs,
		newHistoryKlineResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindVisibleExchangeCoins": kitex.NewMethodInfo(
		findVisibleExchangeCoinsHandler,
		newFindVisibleExchangeCoinsArgs,
		newFindVisibleExchangeCoinsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindAllCoin": kitex.NewMethodInfo(
		findAllCoinHandler,
		newFindAllCoinArgs,
		newFindAllCoinResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"FindCoinById": kitex.NewMethodInfo(
		findCoinByIdHandler,
		newFindCoinByIdArgs,
		newFindCoinByIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	marketServiceInfo                = NewServiceInfo()
	marketServiceInfoForClient       = NewServiceInfoForClient()
	marketServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return marketServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return marketServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return marketServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "Market"
	handlerType := (*market.Market)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "market",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.10.3",
		Extra:           extra,
	}
	return svcInfo
}

func findSymbolThumbHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindSymbolThumb(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindSymbolThumbArgs:
		success, err := handler.(market.Market).FindSymbolThumb(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindSymbolThumbResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindSymbolThumbArgs() interface{} {
	return &FindSymbolThumbArgs{}
}

func newFindSymbolThumbResult() interface{} {
	return &FindSymbolThumbResult{}
}

type FindSymbolThumbArgs struct {
	Req *market.MarketReq
}

func (p *FindSymbolThumbArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindSymbolThumbArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindSymbolThumbArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindSymbolThumbArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindSymbolThumbArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindSymbolThumbArgs_Req_DEFAULT *market.MarketReq

func (p *FindSymbolThumbArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindSymbolThumbArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindSymbolThumbArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindSymbolThumbArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindSymbolThumbResult struct {
	Success *market.SymbolThumbRes
}

var FindSymbolThumbResult_Success_DEFAULT *market.SymbolThumbRes

func (p *FindSymbolThumbResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.SymbolThumbRes)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindSymbolThumbResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindSymbolThumbResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindSymbolThumbResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindSymbolThumbResult) Unmarshal(in []byte) error {
	msg := new(market.SymbolThumbRes)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindSymbolThumbResult) GetSuccess() *market.SymbolThumbRes {
	if !p.IsSetSuccess() {
		return FindSymbolThumbResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindSymbolThumbResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.SymbolThumbRes)
}

func (p *FindSymbolThumbResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindSymbolThumbResult) GetResult() interface{} {
	return p.Success
}

func findSymbolThumbTrendHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindSymbolThumbTrend(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindSymbolThumbTrendArgs:
		success, err := handler.(market.Market).FindSymbolThumbTrend(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindSymbolThumbTrendResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindSymbolThumbTrendArgs() interface{} {
	return &FindSymbolThumbTrendArgs{}
}

func newFindSymbolThumbTrendResult() interface{} {
	return &FindSymbolThumbTrendResult{}
}

type FindSymbolThumbTrendArgs struct {
	Req *market.MarketReq
}

func (p *FindSymbolThumbTrendArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindSymbolThumbTrendArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindSymbolThumbTrendArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindSymbolThumbTrendArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindSymbolThumbTrendArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindSymbolThumbTrendArgs_Req_DEFAULT *market.MarketReq

func (p *FindSymbolThumbTrendArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindSymbolThumbTrendArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindSymbolThumbTrendArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindSymbolThumbTrendArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindSymbolThumbTrendResult struct {
	Success *market.SymbolThumbRes
}

var FindSymbolThumbTrendResult_Success_DEFAULT *market.SymbolThumbRes

func (p *FindSymbolThumbTrendResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.SymbolThumbRes)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindSymbolThumbTrendResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindSymbolThumbTrendResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindSymbolThumbTrendResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindSymbolThumbTrendResult) Unmarshal(in []byte) error {
	msg := new(market.SymbolThumbRes)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindSymbolThumbTrendResult) GetSuccess() *market.SymbolThumbRes {
	if !p.IsSetSuccess() {
		return FindSymbolThumbTrendResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindSymbolThumbTrendResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.SymbolThumbRes)
}

func (p *FindSymbolThumbTrendResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindSymbolThumbTrendResult) GetResult() interface{} {
	return p.Success
}

func findSymbolInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindSymbolInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindSymbolInfoArgs:
		success, err := handler.(market.Market).FindSymbolInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindSymbolInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindSymbolInfoArgs() interface{} {
	return &FindSymbolInfoArgs{}
}

func newFindSymbolInfoResult() interface{} {
	return &FindSymbolInfoResult{}
}

type FindSymbolInfoArgs struct {
	Req *market.MarketReq
}

func (p *FindSymbolInfoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindSymbolInfoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindSymbolInfoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindSymbolInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindSymbolInfoArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindSymbolInfoArgs_Req_DEFAULT *market.MarketReq

func (p *FindSymbolInfoArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindSymbolInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindSymbolInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindSymbolInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindSymbolInfoResult struct {
	Success *market.ExchangeCoin
}

var FindSymbolInfoResult_Success_DEFAULT *market.ExchangeCoin

func (p *FindSymbolInfoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.ExchangeCoin)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindSymbolInfoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindSymbolInfoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindSymbolInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindSymbolInfoResult) Unmarshal(in []byte) error {
	msg := new(market.ExchangeCoin)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindSymbolInfoResult) GetSuccess() *market.ExchangeCoin {
	if !p.IsSetSuccess() {
		return FindSymbolInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindSymbolInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.ExchangeCoin)
}

func (p *FindSymbolInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindSymbolInfoResult) GetResult() interface{} {
	return p.Success
}

func findCoinInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindCoinInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindCoinInfoArgs:
		success, err := handler.(market.Market).FindCoinInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindCoinInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindCoinInfoArgs() interface{} {
	return &FindCoinInfoArgs{}
}

func newFindCoinInfoResult() interface{} {
	return &FindCoinInfoResult{}
}

type FindCoinInfoArgs struct {
	Req *market.MarketReq
}

func (p *FindCoinInfoArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindCoinInfoArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindCoinInfoArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindCoinInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindCoinInfoArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindCoinInfoArgs_Req_DEFAULT *market.MarketReq

func (p *FindCoinInfoArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindCoinInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindCoinInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindCoinInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindCoinInfoResult struct {
	Success *market.Coin
}

var FindCoinInfoResult_Success_DEFAULT *market.Coin

func (p *FindCoinInfoResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.Coin)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindCoinInfoResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindCoinInfoResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindCoinInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindCoinInfoResult) Unmarshal(in []byte) error {
	msg := new(market.Coin)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindCoinInfoResult) GetSuccess() *market.Coin {
	if !p.IsSetSuccess() {
		return FindCoinInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindCoinInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.Coin)
}

func (p *FindCoinInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindCoinInfoResult) GetResult() interface{} {
	return p.Success
}

func historyKlineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).HistoryKline(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *HistoryKlineArgs:
		success, err := handler.(market.Market).HistoryKline(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*HistoryKlineResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newHistoryKlineArgs() interface{} {
	return &HistoryKlineArgs{}
}

func newHistoryKlineResult() interface{} {
	return &HistoryKlineResult{}
}

type HistoryKlineArgs struct {
	Req *market.MarketReq
}

func (p *HistoryKlineArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *HistoryKlineArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *HistoryKlineArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *HistoryKlineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *HistoryKlineArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var HistoryKlineArgs_Req_DEFAULT *market.MarketReq

func (p *HistoryKlineArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return HistoryKlineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *HistoryKlineArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *HistoryKlineArgs) GetFirstArgument() interface{} {
	return p.Req
}

type HistoryKlineResult struct {
	Success *market.HistoryRes
}

var HistoryKlineResult_Success_DEFAULT *market.HistoryRes

func (p *HistoryKlineResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.HistoryRes)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *HistoryKlineResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *HistoryKlineResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *HistoryKlineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *HistoryKlineResult) Unmarshal(in []byte) error {
	msg := new(market.HistoryRes)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *HistoryKlineResult) GetSuccess() *market.HistoryRes {
	if !p.IsSetSuccess() {
		return HistoryKlineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *HistoryKlineResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.HistoryRes)
}

func (p *HistoryKlineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *HistoryKlineResult) GetResult() interface{} {
	return p.Success
}

func findVisibleExchangeCoinsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindVisibleExchangeCoins(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindVisibleExchangeCoinsArgs:
		success, err := handler.(market.Market).FindVisibleExchangeCoins(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindVisibleExchangeCoinsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindVisibleExchangeCoinsArgs() interface{} {
	return &FindVisibleExchangeCoinsArgs{}
}

func newFindVisibleExchangeCoinsResult() interface{} {
	return &FindVisibleExchangeCoinsResult{}
}

type FindVisibleExchangeCoinsArgs struct {
	Req *market.MarketReq
}

func (p *FindVisibleExchangeCoinsArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindVisibleExchangeCoinsArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindVisibleExchangeCoinsArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindVisibleExchangeCoinsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindVisibleExchangeCoinsArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindVisibleExchangeCoinsArgs_Req_DEFAULT *market.MarketReq

func (p *FindVisibleExchangeCoinsArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindVisibleExchangeCoinsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindVisibleExchangeCoinsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindVisibleExchangeCoinsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindVisibleExchangeCoinsResult struct {
	Success *market.ExchangeCoinRes
}

var FindVisibleExchangeCoinsResult_Success_DEFAULT *market.ExchangeCoinRes

func (p *FindVisibleExchangeCoinsResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.ExchangeCoinRes)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindVisibleExchangeCoinsResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindVisibleExchangeCoinsResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindVisibleExchangeCoinsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindVisibleExchangeCoinsResult) Unmarshal(in []byte) error {
	msg := new(market.ExchangeCoinRes)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindVisibleExchangeCoinsResult) GetSuccess() *market.ExchangeCoinRes {
	if !p.IsSetSuccess() {
		return FindVisibleExchangeCoinsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindVisibleExchangeCoinsResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.ExchangeCoinRes)
}

func (p *FindVisibleExchangeCoinsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindVisibleExchangeCoinsResult) GetResult() interface{} {
	return p.Success
}

func findAllCoinHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindAllCoin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindAllCoinArgs:
		success, err := handler.(market.Market).FindAllCoin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindAllCoinResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindAllCoinArgs() interface{} {
	return &FindAllCoinArgs{}
}

func newFindAllCoinResult() interface{} {
	return &FindAllCoinResult{}
}

type FindAllCoinArgs struct {
	Req *market.MarketReq
}

func (p *FindAllCoinArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindAllCoinArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindAllCoinArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindAllCoinArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindAllCoinArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindAllCoinArgs_Req_DEFAULT *market.MarketReq

func (p *FindAllCoinArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindAllCoinArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindAllCoinArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindAllCoinArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindAllCoinResult struct {
	Success *market.CoinList
}

var FindAllCoinResult_Success_DEFAULT *market.CoinList

func (p *FindAllCoinResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.CoinList)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindAllCoinResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindAllCoinResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindAllCoinResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindAllCoinResult) Unmarshal(in []byte) error {
	msg := new(market.CoinList)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindAllCoinResult) GetSuccess() *market.CoinList {
	if !p.IsSetSuccess() {
		return FindAllCoinResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindAllCoinResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.CoinList)
}

func (p *FindAllCoinResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindAllCoinResult) GetResult() interface{} {
	return p.Success
}

func findCoinByIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(market.MarketReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(market.Market).FindCoinById(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *FindCoinByIdArgs:
		success, err := handler.(market.Market).FindCoinById(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FindCoinByIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newFindCoinByIdArgs() interface{} {
	return &FindCoinByIdArgs{}
}

func newFindCoinByIdResult() interface{} {
	return &FindCoinByIdResult{}
}

type FindCoinByIdArgs struct {
	Req *market.MarketReq
}

func (p *FindCoinByIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(market.MarketReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *FindCoinByIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *FindCoinByIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *FindCoinByIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *FindCoinByIdArgs) Unmarshal(in []byte) error {
	msg := new(market.MarketReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FindCoinByIdArgs_Req_DEFAULT *market.MarketReq

func (p *FindCoinByIdArgs) GetReq() *market.MarketReq {
	if !p.IsSetReq() {
		return FindCoinByIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FindCoinByIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *FindCoinByIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type FindCoinByIdResult struct {
	Success *market.Coin
}

var FindCoinByIdResult_Success_DEFAULT *market.Coin

func (p *FindCoinByIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(market.Coin)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *FindCoinByIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *FindCoinByIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *FindCoinByIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *FindCoinByIdResult) Unmarshal(in []byte) error {
	msg := new(market.Coin)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FindCoinByIdResult) GetSuccess() *market.Coin {
	if !p.IsSetSuccess() {
		return FindCoinByIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FindCoinByIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*market.Coin)
}

func (p *FindCoinByIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FindCoinByIdResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) FindSymbolThumb(ctx context.Context, Req *market.MarketReq) (r *market.SymbolThumbRes, err error) {
	var _args FindSymbolThumbArgs
	_args.Req = Req
	var _result FindSymbolThumbResult
	if err = p.c.Call(ctx, "FindSymbolThumb", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindSymbolThumbTrend(ctx context.Context, Req *market.MarketReq) (r *market.SymbolThumbRes, err error) {
	var _args FindSymbolThumbTrendArgs
	_args.Req = Req
	var _result FindSymbolThumbTrendResult
	if err = p.c.Call(ctx, "FindSymbolThumbTrend", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindSymbolInfo(ctx context.Context, Req *market.MarketReq) (r *market.ExchangeCoin, err error) {
	var _args FindSymbolInfoArgs
	_args.Req = Req
	var _result FindSymbolInfoResult
	if err = p.c.Call(ctx, "FindSymbolInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindCoinInfo(ctx context.Context, Req *market.MarketReq) (r *market.Coin, err error) {
	var _args FindCoinInfoArgs
	_args.Req = Req
	var _result FindCoinInfoResult
	if err = p.c.Call(ctx, "FindCoinInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) HistoryKline(ctx context.Context, Req *market.MarketReq) (r *market.HistoryRes, err error) {
	var _args HistoryKlineArgs
	_args.Req = Req
	var _result HistoryKlineResult
	if err = p.c.Call(ctx, "HistoryKline", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindVisibleExchangeCoins(ctx context.Context, Req *market.MarketReq) (r *market.ExchangeCoinRes, err error) {
	var _args FindVisibleExchangeCoinsArgs
	_args.Req = Req
	var _result FindVisibleExchangeCoinsResult
	if err = p.c.Call(ctx, "FindVisibleExchangeCoins", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindAllCoin(ctx context.Context, Req *market.MarketReq) (r *market.CoinList, err error) {
	var _args FindAllCoinArgs
	_args.Req = Req
	var _result FindAllCoinResult
	if err = p.c.Call(ctx, "FindAllCoin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FindCoinById(ctx context.Context, Req *market.MarketReq) (r *market.Coin, err error) {
	var _args FindCoinByIdArgs
	_args.Req = Req
	var _result FindCoinByIdResult
	if err = p.c.Call(ctx, "FindCoinById", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
